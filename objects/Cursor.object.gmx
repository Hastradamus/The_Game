<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>crosshair_s</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Adding controller support

curButton = noone; //tmp line
curButt = instance_nearest(0, 0, Button);
buttonIndex = 0;
buttons = noone;
dz = .11; //gamepad deadzone. needed because gamepad_set_axis_deadzone wasn't working properly
alreadyExecuted = false;
controller = false;
var deviceCount = gamepad_get_device_count();
if (deviceCount &gt; 0){
    controller = true;
    for(var i = 0; i &lt; deviceCount; i++){
        gamepad_set_axis_deadzone(i, dz);
    }
    /* load all the Button s into the array called buttons,
    this will allow us to have the player cycle through them 
    when they press the joy stick up,
    down, left, or right. */
    for (var i = 0; i &lt; instance_number(Button); i++){
    buttons[i] = instance_find(Button, i);
    }
}
/* mouseLastX-- used for stuff in the step event */
mouseLastX = mouse_x;
mouseLastY = mouse_y;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/* if(mouseLastX != ...) this check is to give control of the cursor to the mouse
as well as unhighlight the current button if the mouse isn't colliding
with a button at the time. also sets cursor's visibility to true*/
if(mouseLastX != mouse_x || mouseLastY != mouse_y){
    self.visible = true;
    controller = false;
    var curButton = instance_place(mouse_x, mouse_y, Button);
    
    /* if the mouse isn't colliding with a button then curButton will
    be set to noone, and as such there shouldn't be a button that is highlighted
    */
    if(curButton == noone){
        with Button event_perform(ev_mouse, ev_mouse_leave);
    }
    
}
if (controller == false){
    x = mouse_x;
    y = mouse_y;
}

    mouseLastX = mouse_x;
    mouseLastY = mouse_y;

/* lsv: gamepads left stick vertical movment */
var lsv = gamepad_axis_value(0, gp_axislv);
/* lsh: gamepad's Left Stick Vertical movement */
var lsh = gamepad_axis_value(0, gp_axislh);

/* this is used to give the cursor's control to the controller, the check is simply
weather the left stick is pressed any direction. its kind of just a convenience to seperat
logic. also when the controller has control of the cursor it is set to invible*/
if(lsh &lt;= -dz || lsh &gt;= dz || lsv &lt;= -dz || lsv &gt;= dz){
   controller = true;
   self.visible = false;
}

/* if(lsh &gt;= -dz &amp;&amp; lsh &lt;= dz): this check to see that the left stick is between the
positive and negative 'dead zones', if it is then makes it possible for the next
executions to happen when the player presses the stick again */
if(lsh &gt;= -dz &amp;&amp; lsh &lt;= dz &amp;&amp;
    lsv &gt;= -dz &amp;&amp; lsv &lt;= dz){
    /* alreadyExecuted: protection from when you press the stick to the right
    and it adds 100 to the buttonIndex because it happens every tick. Essentiall
    it helps thing to be executed one at a time. its set to false once the players stick is
    registed to be back at 0 */
    alreadyExecuted = false;
}


if(buttons != noone){
    if(!alreadyExecuted){
        //left stick pushed: RIGHT
        /* if(lsh &gt; 0): if the left stick is pressed to the right, do thing */
        if(lsh &gt; dz){
            if(curButt != noone) with curButt event_perform(ev_mouse, ev_mouse_leave);
            curButt = buttonNextRight_script(curButt);
            with curButt event_perform(ev_mouse, ev_mouse_enter);
            alreadyExecuted = true;
            
        }
        //left stick pushed: LEFT
        /* if(lsh &lt; -dz): if left stick is pushed left
         do the same as above, except going left instead of right */
        if(lsh &lt; -dz){
           if(curButt != noone) with curButt event_perform(ev_mouse, ev_mouse_leave);
            curButt = buttonNextLeft_script(curButt);
            with curButt event_perform(ev_mouse, ev_mouse_enter);
            alreadyExecuted = true;
            
        }
        //left stick pushed: UP
        /* if(lsv &gt; dz): if left stick is pushed up: do the same as
        left stick pushed right */
        if(lsv &gt; dz){
            if(curButt != noone) with curButt event_perform(ev_mouse, ev_mouse_leave);
            curButt = buttonNextRight_script(curButt);
            with curButt event_perform(ev_mouse, ev_mouse_enter);
            alreadyExecuted = true;
        }
        // left stick pushed: DOWN
        /* if(lsv &gt; dz): if left stick is pushed down: do the same as
        left stick pushed left */
        if(lsv &lt; -dz){
            if(curButt != noone) with curButt event_perform(ev_mouse, ev_mouse_leave);
            curButt = buttonNextLeft_script(curButt);
            with curButt event_perform(ev_mouse, ev_mouse_enter);
            alreadyExecuted = true;
        }
        
        
    }
    /* if(gamepad_button_check(0, gp_face1): check if the 'A' button is released */
    if(gamepad_button_check_released(0, gp_face1)){
    controller = true;
    with curButt event_perform(ev_mouse, ev_left_button);
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="50">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>controller = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
